Aqua Protocol
Github Release CI Coverage Tests npm License Solidity Foundry Whitepaper

Shared liquidity layer protocol enabling liquidity providers to allocate balances across multiple trading strategies without fragmentation.

Table of Contents
Overview
Architecture
Core Concepts
Usage
For Liquidity Providers
For Traders
For Developers
API Reference
Getting Started
Traditional AMM Pools                 Aqua Protocol
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”         â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Single LP:                                    Single LP:

   [LP]                                         [LP]($$)
    â”‚                                              â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
    â”‚         â”‚         â”‚                          â”‚
    â”‚         â”‚         â”‚                      â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”                 â”‚  Aqua  â”‚
â”‚  AMM   â”‚â”‚  AMM   â”‚â”‚  AMM   â”‚                 â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
â”‚ Pool A â”‚â”‚ Pool B â”‚â”‚ Pool C â”‚                     â”‚
â”‚  ($$)  â”‚â”‚  ($$)  â”‚â”‚  ($$)  â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜            â”‚        â”‚        â”‚
    â”‚         â”‚         â”‚                 â”‚        â”‚        â”‚
 [Taker]   [Taker]   [Taker]          â”Œâ”€â”€â”€â–¼â”€â”€â”€â”â”Œâ”€â”€â”€â–¼â”€â”€â”€â”â”Œâ”€â”€â”€â–¼â”€â”€â”€â”
                                      â”‚ Aqua  â”‚â”‚ Aqua  â”‚â”‚ Aqua  â”‚
                                      â”‚ AMM A â”‚â”‚ AMM B â”‚â”‚ AMM C â”‚
                                      â””â”€â”€â”€â”¬â”€â”€â”€â”˜â””â”€â”€â”€â”¬â”€â”€â”€â”˜â””â”€â”€â”€â”¬â”€â”€â”€â”˜
                                          â”‚        â”‚        â”‚
                                      [Taker]   [Taker]   [Taker]

âŒ Traditional AMM Pools:              âœ… Aqua Protocol:
   â€¢ Liquidity fragmented across         â€¢ Shared liquidity via AQUA
     multiple isolated pools               virtual balances
   â€¢ Capital ($$) locked in pools        â€¢ Capital ($$) stays in wallet
Overview
Traditional DeFi protocols fragment liquidity by locking it in isolated pools. Aqua solves this through a registry-based allowance system where liquidity providers maintain a single token approval while distributing virtual balances across multiple strategies.

Key Benefits:

Unified Liquidity: Single approval enables participation in unlimited strategies
Capital Efficiency: Share liquidity across protocols without redeployment
Granular Control: Per-strategy balance management
No Custody: Tokens remain in LP wallets, only virtual balances tracked
Architecture
Components
Aqua.sol - Core registry contract

Stores virtual balances: balances[maker][app][strategyHash][token]
Manages lifecycle: ship(), dock()
Provides swap interface: pull(), push()
AquaApp - Base contract for trading applications

Inherits to build AMMs, limit orders, auctions, etc.
Accesses liquidity via Aqua interface
Enforces reentrancy protection for safe callbacks
Strategy - Configuration identifier

Defined by app-specific struct (e.g., token pair, fee, parameters)
Identified by keccak256(abi.encode(strategy))
Immutable once shipped
Core Concepts
Virtual Balances
Aqua doesn't hold tokens - it maintains allowance records. Actual tokens remain in maker wallets until pulled during trades.

mapping(address maker =>
    mapping(address app =>
        mapping(bytes32 strategyHash =>
            mapping(address token => Balance)))) private _balances;
Important: Funds ($$$) always stay in the LP's wallet. AQUA only tracks virtual balance allocations.

Strategy Hash
Uniquely identifies strategy configurations:

bytes32 strategyHash = keccak256(abi.encode(strategy));
Ensures same parameters always produce same identifier.

Strategy Immutability
Once a strategy is shipped, it becomes completely immutable:

âœ— Parameters cannot be changed (e.g., fee rates, token pairs, weights)
âœ— Initial liquidity amounts cannot be modified
âœ“ Token balances change ONLY through swap execution via pull()/push()
Why Immutability?

Immutable data structures significantly reduce bugs in concurrent and distributed systems. As noted in the seminal paper "Out of the Tar Pit" by Ben Moseley and Peter Marks, immutability eliminates entire classes of bugs related to state management and makes systems vastly easier to reason about.

Easy Re-parameterization:

Since strategies don't own funds (tokens remain in your wallet with approval), you can easily adjust parameters:

dock(strategyHash) - Withdraws virtual balances (no token transfers, just accounting)
ship(newStrategy) - Creates new strategy with updated parameters and/or liquidity allocations
This flexibility combines the safety of immutability with practical adaptability.

Pull/Push Interface
âš¡ Important: Swap Execution Only

pull() and push() are used exclusively during swap execution to transfer tokens between makers and takers. They are NOT used for liquidity management. Initial liquidity is set via ship() and shouldn't be modified afterward.

Pull: App withdraws tokens from maker to trader during swap

aqua.pull(maker, strategyHash, tokenOut, amountOut, recipient);
Push: Trader deposits tokens into maker's strategy balance during swap

aqua.push(maker, app, strategyHash, tokenIn, amountIn);
Liquidity Management:

Add liquidity â†’ Use ship() to create new strategy
Remove liquidity â†’ Use dock() to withdraw from strategy
Change parameters â†’ Use dock() then ship() new strategy
Usage
For Liquidity Providers
ðŸ’¡ Strategy Management

Immutable: Once shipped, parameters and initial liquidity are locked
No custody: Your tokens stay in your wallet with approval to Aqua
Easy updates: dock() â†’ ship() to change parameters (no token transfers needed)
Safer code: Immutability means fewer bugs and easier integration for traders
1. Approve tokens to Aqua (one-time)

token.approve(address(aqua), type(uint256).max);
2. Ship a strategy

XYCSwap.Strategy memory strategy = XYCSwap.Strategy({
    maker: msg.sender,
    token0: DAI,
    token1: USDC,
    feeBps: 30,  // 0.3%
    salt: bytes32(0)
});

address[] memory tokens = new address[](2);
tokens[0] = DAI;
tokens[1] = USDC;

uint256[] memory amounts = new uint256[](2);
amounts[0] = 1000e18;  // 1000 DAI
amounts[1] = 1000e6;   // 1000 USDC

bytes32 strategyHash = aqua.ship(
    address(xycSwapApp),
    abi.encode(strategy),
    tokens,
    amounts
);
3. Manage strategies

// Check balance
(uint256 balanceIn, balanceOut) = aqua.safeBalances(maker, app, strategyHash, tokenIn, tokenOut);

// Withdraw liquidity and deactivate strategy
aqua.dock(app, strategyHash, tokens);

// To change parameters or liquidity:
// 1. dock() existing strategy
// 2. ship() new strategy with updated params
For Traders
1. Implement specific callback interface

contract Trader is IAquaAppSwapCallback {
    function aquaAppSwapCallback(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 amountOut,
        address maker,
        address app,
        bytes32 strategyHash,
        bytes calldata takerData
    ) external override {
        // Transfer tokenIn to complete the swap (requires token approval)
        // This is the ONLY appropriate use of push() - during swap execution
        IERC20(tokenIn).forceApprove(aqua, amountIn);
        aqua.push(maker, app, strategyHash, tokenIn, amountIn);
    }
}
2. Execute trades

aquaApp.swapExactIn(
    strategy,
    true,              // zeroForOne
    1e18,              // amountIn
    0.99e18,           // amountOutMin
    address(this),     // recipient
    ""                 // takerData
);
For Developers
1. Inherit from AquaApp

contract MyAMM is AquaApp {
    constructor(IAqua aqua) AquaApp(aqua) {}

    struct Strategy {
        address maker; // Must-have to make strategyHash unique per user
        address token0;
        address token1;
        // ... strategy parameters (IMMUTABLE once shipped)
    }
}
2. Implement trading logic

function swap(
    Strategy calldata strategy,
    bool isZeroForOne,
    uint256 amountIn
)
    external
    nonReentrantStrategy(keccak256(abi.encode(strategy)))
    returns (uint256 amountOut)
{
    bytes32 strategyHash = keccak256(abi.encode(strategy));

    address tokenIn = isZeroForOne ? strategy.token0 : strategy.token1;
    address tokenOut = isZeroForOne ? strategy.token1 : strategy.token0;

    (uint256 balanceIn, uint256 balanceOut) = AQUA.safeBalances(strategy.maker, address(this), strategyHash, tokenIn, tokenOut);

    amountOut = // ... compute output amount based on AMM logic
    uint256 expectedBalanceIn = balanceIn + amountIn;

    // Pull output tokens to recipient (SWAP EXECUTION)
    AQUA.pull(strategy.maker, strategyHash, tokenOut, amountOut, recipient);

    // Callback for input tokens
    IXYCSwapCallback(msg.sender).xycSwapCallback(
        tokenIn, tokenOut, amountIn, amountOut,
        strategy.maker, address(this), strategyHash, takerData
    );

    // Verify input received (SWAP EXECUTION)
    _safeCheckAquaPush(strategy.maker, strategyHash, tokenIn, expectedBalanceIn);
}
Method AquaApp._safeCheckAquaPush() is efficient but requires reentrancy protection to prevent nested swaps. Another option is to manually transfer tokens from taker and push to Aqua, no reentrancy protection needed:

function swap(
    Strategy calldata strategy,
    bool isZeroForOne,
    uint256 amountIn
) external returns (uint256 amountOut) {
    bytes32 strategyHash = keccak256(abi.encode(strategy));

    address tokenIn = isZeroForOne ? strategy.token0 : strategy.token1;
    address tokenOut = isZeroForOne ? strategy.token1 : strategy.token0;

    (uint256 balanceIn, uint256 balanceOut) = AQUA.safeBalances(strategy.maker, address(this), strategyHash, tokenIn, tokenOut);

    amountOut = // ... compute output amount based on AMM logic

    // Pull output tokens to recipient (SWAP EXECUTION)
    AQUA.pull(strategy.maker, strategyHash, tokenOut, amountOut, recipient);

    // Transfer input tokens from taker and push to Aqua (SWAP EXECUTION)
    IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);
    IERC20(tokenIn).approve(address(AQUA), amountIn);
    AQUA.push(strategy.maker, address(this), strategyHash, tokenIn, amountIn);
}
Safe Balance Queries

Use safeBalances() when you need to ensure that queried tokens are part of the active strategy. This is particularly important for:

Multi-token AMM strategies
Strategies with multiple tokens
Verifying strategy validity before executing swaps
The function reverts if any token is not part of the strategy, preventing calculation errors.

// Safe balance check before swap
(uint256 balanceIn, uint256 balanceOut) = AQUA.safeBalances(
    strategy.maker, 
    address(this), 
    strategyHash, 
    tokenIn,
    tokenOut
);
// Transaction reverts if any token is not in the strategy
Taker example Implementation

contract SimpleTrader is IXYCSwapCallback {
    IAqua public immutable AQUA;

    constructor(IAqua _aqua, IERC20[] memory tokens) {
        AQUA = _aqua;
        for (uint256 i = 0; i < tokens.length; i++) {
            tokens[i].approve(address(AQUA), type(uint256).max);
        }
    }

    function swap(
        XYCSwap app,
        XYCSwap.Strategy calldata strategy,
        bool zeroForOne,
        uint256 amountIn
    ) external {
        app.swapExactIn(
            strategy,
            zeroForOne,
            amountIn,
            0,           // amountOutMin (calculate properly in production)
            msg.sender,  // recipient
            ""           // takerData
        );
    }

    function xycSwapCallback(
        address tokenIn,
        address,  // tokenOut
        uint256 amountIn,
        uint256,  // amountOut
        address maker,
        address app,
        bytes32 strategyHash,
        bytes calldata
    ) external override {
        // Transfer input tokens to complete swap (SWAP EXECUTION ONLY)
        AQUA.push(maker, app, strategyHash, tokenIn, amountIn);
    }
}
API Reference
Aqua Core
// Liquidity Lifecycle Management
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

// Ship new strategy with initial balances (immutable after creation)
function ship(
    address app,
    bytes calldata strategy,
    address[] calldata tokens,
    uint256[] calldata amounts
) external returns(bytes32 strategyHash);

// Deactivate strategy and withdraw all balances
function dock(
    address app,
    bytes32 strategyHash,
    address[] calldata tokens
) external;

// Swap Execution Only
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

// Pull tokens from maker during swap (called by apps)
function pull(
    address maker,
    bytes32 strategyHash,
    address token,
    uint256 amount,
    address to
) external;

// Push tokens to maker's strategy balance during swap
function push(
    address maker,
    address app,
    bytes32 strategyHash,
    address token,
    uint256 amount
) external;

// Queries
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

// Query virtual balance
function rawBalances(
    address maker,
    address app,
    bytes32 strategyHash,
    address token
) external view returns (uint248 balance, uint8 tokensCount);

// Query multiple token balances with active strategy validation
// Reverts if any token is not part of the active strategy
function safeBalances(
    address maker,
    address app,
    bytes32 strategyHash,
    address token0,
    address token1
) external view returns (uint256 balance0, uint256 balance1);
AquaApp Base Contract
// Immutable reference to Aqua registry
IAqua public immutable AQUA;

// Reentrancy locks per strategy (strategyHash already includes maker)
mapping(bytes32 strategyHash => TransientLock) internal _reentrancyLocks;

// Convenient modifier for reentrancy protection
modifier nonReentrantStrategy(bytes32 strategyHash);

// Helper to verify taker deposited tokens (requires reentrancy protection)
function _safeCheckAquaPush(
    address maker,
    bytes32 strategyHash,
    address token,
    uint256 expectedBalance
) internal view;
Getting Started
# Clone repository
git clone https://github.com/1inch/aqua
cd aqua

# Install dependencies
forge install

# Run tests
forge test
Deployments
The Aqua Protocol is deployed across multiple networks at the same address:

Contract Address: 0x499943e74fb0ce105688beee8ef2abec5d936d31

Supported Networks
Network	Contract Address
Ethereum Mainnet	0x499943e74fb0ce105688beee8ef2abec5d936d31
Base	0x499943e74fb0ce105688beee8ef2abec5d936d31
Optimism	0x499943e74fb0ce105688beee8ef2abec5d936d31
Polygon	0x499943e74fb0ce105688beee8ef2abec5d936d31
Arbitrum	0x499943e74fb0ce105688beee8ef2abec5d936d31
Avalanche	0x499943e74fb0ce105688beee8ef2abec5d936d31
Binance Smart Chain	0x499943e74fb0ce105688beee8ef2abec5d936d31
Linea	0x499943e74fb0ce105688beee8ef2abec5d936d31
Sonic	0x499943e74fb0ce105688beee8ef2abec5d936d31
Unichain	0x499943e74fb0ce105688beee8ef2abec5d936d31
Gnosis	0x499943e74fb0ce105688beee8ef2abec5d936d31
zkSync	0x499943e74fb0ce105688beee8ef2abec5d936d31
License
This project is licensed under the LicenseRef-Degensoft-Aqua-Source-1.1

See the LICENSE file for details. See the THIRD_PARTY_NOTICES file for information about third-party software, libraries, and dependencies used in this project.

Contact for licensing inquiries:

ðŸ“§ license@degensoft.com
ðŸ“§ legal@degensoft.com


-----------------------


@1inch/aqua-sdk - TypeScript SDK for 1inch Aqua Protocol
A TypeScript SDK for encoding, decoding, and interacting with the 1inch Aqua Protocol smart contract. This SDK provides utilities for building transactions and parsing events for the Aqua Protocol's core operations.

Overview
The Aqua Protocol is a decentralized protocol for liquidity management. This SDK simplifies integration by providing:

Encoding/Decoding: Build typed call data for ship, dock operations
Event Parsing: Decode and parse Pushed, Pulled, Shipped, and Docked events
Multi-Chain Support: Pre-configured addresses for 10+ blockchain networks
For detailed protocol documentation, see the Aqua Protocol Documentation.

Installation
pnpm add @1inch/aqua-sdk
Quick Start
import {
  AquaProtocolContract,
  AQUA_CONTRACT_ADDRESSES,
  Address,
  HexString,
  NetworkEnum
} from '@1inch/aqua-sdk'

// Initialize the contract
const contractAddress = AQUA_CONTRACT_ADDRESSES[NetworkEnum.ETHEREUM]
const aqua = new AquaProtocolContract(contractAddress)

// Build a ship transaction
const shipTx = aqua.ship({
  app: new Address('0x...'),
  strategy: new HexString('0x...'),
  amountsAndTokens: [
    {
      token: new Address('0x...'),
      amount: 1000000000000000000n, // 1 token with 18 decimals
    },
  ],
})

// Use the transaction data
console.log(shipTx) // { to: '0x...', data: '0x...', value: 0n }
Core Operations
Ship
Initiates a liquidity strategy by setting virtual token balances for it.

const shipTx = aqua.ship({
  app: new Address('0x...'),
  strategy: new HexString('0x...'),
  amountsAndTokens: [
    {
      token: new Address('0x...'),
      amount: 1000000000000000000n,
    },
  ],
})
Parameters:

app - Address of the application contract
strategy - Strategy bytes containing execution logic
amountsAndTokens - Array of token addresses and amounts to ship
Returns: CallInfo object with encoded transaction data

Dock
Completes a liquidity strategy by removing virtual token balances from it.

const strategyHash = AquaProtocolContract.calculateStrategyHash(strategy)

const dockTx = aqua.dock({
  app: new Address('0x...'),
  strategyHash: strategyHash,
  tokens: [
    new Address('0x...'),
    new Address('0x...'),
  ],
})
Parameters:

app - Address of the application contract
strategyHash - Keccak256 hash of the strategy bytes
tokens - Array of token addresses to withdraw
Returns: CallInfo object with encoded transaction data

Event Parsing
Pushed Event
Emitted when funds are pushed to a strategy/wallet.

import { PushedEvent } from '@1inch/aqua-sdk'

const log = { data: '0x...', topics: ['0x...'] }
const event = PushedEvent.fromLog(log)

console.log(event.maker)        // Address
console.log(event.app)          // Address
console.log(event.strategyHash) // HexString
console.log(event.token)        // Address
console.log(event.amount)       // bigint
Pulled Event
Emitted when funds are pulled from a strategy/wallet.

import { PulledEvent } from '@1inch/aqua-sdk'

const event = PulledEvent.fromLog(log)
Shipped Event
Emitted when a liquidity strategy is initiated.

import { ShippedEvent } from '@1inch/aqua-sdk'

const event = ShippedEvent.fromLog(log)
Docked Event
Emitted when a liquidity strategy is closed.

import { DockedEvent } from '@1inch/aqua-sdk'

const event = DockedEvent.fromLog(log)
Utility Functions
Calculate Strategy Hash
Convert strategy bytes to their keccak256 hash.

import { AquaProtocolContract } from '@1inch/aqua-sdk'
import { HexString } from '@1inch/sdk-core'

const strategy = new HexString('0x...')
const hash = AquaProtocolContract.calculateStrategyHash(strategy)
Encode Call Data
Manually encode function call data if needed.

import { AquaProtocolContract } from '@1inch/aqua-sdk'

const encodedShip = AquaProtocolContract.encodeShipCallData({
  app: new Address('0x...'),
  strategy: new HexString('0x...'),
  amountsAndTokens: [ /* ... */ ],
})

const encodedDock = AquaProtocolContract.encodeDockCallData({
  app: new Address('0x...'),
  strategyHash: new HexString('0x...'),
  tokens: [ /* ... */ ],
})
Supported Networks
The SDK includes pre-configured contract addresses for the following networks:

Network	Chain ID	Address
Ethereum	1	0x499943e74fb0ce105688beee8ef2abec5d936d31
BNB Chain	56	0x499943e74fb0ce105688beee8ef2abec5d936d31
Polygon	137	0x499943e74fb0ce105688beee8ef2abec5d936d31
Arbitrum	42161	0x499943e74fb0ce105688beee8ef2abec5d936d31
Avalanche	43114	0x499943e74fb0ce105688beee8ef2abec5d936d31
Gnosis	100	0x499943e74fb0ce105688beee8ef2abec5d936d31
Coinbase Base	8453	0x499943e74fb0ce105688beee8ef2abec5d936d31
Optimism	10	0x499943e74fb0ce105688beee8ef2abec5d936d31
zkSync Era	324	0x499943e74fb0ce105688beee8ef2abec5d936d31
Linea	59144	0x499943e74fb0ce105688beee8ef2abec5d936d31
Unichain	1301	0x499943e74fb0ce105688beee8ef2abec5d936d31
Sonic	146	0x499943e74fb0ce105688beee8ef2abec5d936d31
Access addresses using:

import { AQUA_CONTRACT_ADDRESSES } from '@1inch/aqua-sdk'
import { NetworkEnum } from '@1inch/sdk-core'

const ethereumAddress = AQUA_CONTRACT_ADDRESSES[NetworkEnum.ETHEREUM]
const arbitrumAddress = AQUA_CONTRACT_ADDRESSES[NetworkEnum.ARBITRUM]
API Reference
Exports
The SDK exports:

AquaProtocolContract - Main contract class for encoding, decoding, and building transactions
AQUA_CONTRACT_ADDRESSES - Pre-configured contract addresses by network
ABI - Contract ABI exports
Types:
ShipArgs
DockArgs
AmountsAndTokens
EventAction
Event Classes:
PushedEvent
PulledEvent
ShippedEvent
DockedEvent
Real-Life Examples
Example 1: Ship Liquidity to XYCSwap.sol aqua app
Initialize a liquidity strategy by depositing tokens into Aqua's virtual balance system.

import { encodeAbiParameters, parseUnits, http, createWalletClient, isHex } from 'viem'
import { privateKeyToAccount, privateKeyToAddress } from 'viem/accounts'
import { mainnet } from 'viem/chains'
import assert from 'node:assert'
import 'dotenv/config'

const makerPrivateKey = process.env.MAKER_PRIVATE_KEY

assert(isHex(makerPrivateKey))
const maker = privateKeyToAddress(makerPrivateKey)
const app = '0xTODO_REPLACE'
const WETH = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'
const USDC = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'

// Define strategy based on the smart contract app structure. Each Aqua app can have it's own strategy schema
const strategyData = {
  maker,
  token0: WETH,
  token1: USDC,
  feeBps: 0n,
  salt: '0x0000000000000000000000000000000000000000000000000000000000000001'
} as const

// Encode strategy as bytes
const strategy = encodeAbiParameters(
  [
    {
      name: 'strategy',
      type: 'tuple',
      components: [
        { name: 'maker', type: 'address' },
        { name: 'token0', type: 'address' },
        { name: 'token1', type: 'address' },
        { name: 'feeBps', type: 'uint256' },
        { name: 'salt', type: 'bytes32' }
      ]
    }
  ],
  [strategyData]
)

console.log('Encoded strategy:', strategy)

// Initialize Aqua contract
const aqua = new AquaProtocolContract(AQUA_CONTRACT_ADDRESSES[NetworkEnum.ETHEREUM])

// Create ship transaction
const shipTx = aqua.ship({
  app: new Address(app),
  strategy: new HexString(strategy),
  amountsAndTokens: [
    {
      token: new Address(USDC),
      amount: parseUnits('4000', 6)
    },
    {
      token: new Address(WETH),
      amount: parseUnits('1', 18)
    }
  ]
})

// Send transaction
const wallet = createWalletClient({
  chain: mainnet,
  transport: http(),
  account: privateKeyToAccount(makerPrivateKey)
})

await wallet.sendTransaction(shipTx)

Full test example: tests/aqua.spec.ts - should ship

Example 2: Execute a Swap through XYCSwap.sol aqua app
Execute a swap against liquidity provided through Aqua. TestTrader.sol helper contract is used as an approve holder and router.

import {
  parseUnits,
  http,
  createWalletClient,
  isHex,
  encodeFunctionData,
  decodeAbiParameters,
  publicActions
} from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'
import assert from 'node:assert'
import 'dotenv/config'

const takerPrivateKey = process.env.TAKER_PRIVATE_KEY

assert(isHex(takerPrivateKey))
const USDC = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'
const app = '0xTODOReplace'
const routerAddress = '0xTestTraderAddress'

const strategy = '0x' // parsed from ship events or fetched from api

// Send transaction
const wallet = createWalletClient({
  chain: mainnet,
  transport: http(),
  account: privateKeyToAccount(takerPrivateKey)
}).extend(publicActions)

// decode data based on specified by app format
const [strategyData] = decodeAbiParameters(
  [
    {
      type: 'tuple',
      components: [
        { name: 'maker', type: 'address' },
        { name: 'token0', type: 'address' },
        { name: 'token1', type: 'address' },
        { name: 'feeBps', type: 'uint256' },
        { name: 'salt', type: 'bytes32' }
      ]
    }
  ],
  strategy
)

// Define swap parameters
const srcAmount = parseUnits('10', 6) // 10 USDC
const srcToken = USDC
const isZeroForOne = strategyData.token0 === srcToken

// Encode the swap call to helper Router contract
const swapData = encodeFunctionData({
  abi: [
    {
      type: 'function',
      name: 'swap',
      inputs: [
        {
          name: 'app',
          type: 'address'
        },
        {
          name: 'strategy',
          type: 'tuple',
          components: [
            { name: 'maker', type: 'address' },
            { name: 'token0', type: 'address' },
            { name: 'token1', type: 'address' },
            { name: 'feeBps', type: 'uint256' },
            { name: 'salt', type: 'bytes32' }
          ]
        },
        { name: 'zeroForOne', type: 'bool' },
        { name: 'amountIn', type: 'uint256' }
      ],
      outputs: [{ name: 'amountOut', type: 'uint256' }],
      stateMutability: 'nonpayable'
    }
  ],
  functionName: 'swap',
  args: [app, strategyData, isZeroForOne, srcAmount]
})

// give erc20 approve to routerAddress
await wallet.writeContract({
  abi: [
    {
      type: 'function',
      name: 'approve',
      inputs: [
        { name: 'spender', type: 'address', internalType: 'address' },
        { name: 'value', type: 'uint256', internalType: 'uint256' }
      ],
      outputs: [{ name: '', type: 'bool', internalType: 'bool' }],
      stateMutability: 'nonpayable'
    }
  ],
  address: srcToken,
  account: wallet.account,
  functionName: 'approve',
  chain: wallet.chain,
  args: [routerAddress, srcAmount]
})

// Execute swap
const swapTx = await wallet.sendTransaction({
  to: routerAddress,
  data: swapData
})

await wallet.waitForTransactionReceipt({ hash: swapTx })
Full test example: tests/aqua.spec.ts - should swap

Example 3: Dock Liquidity
Withdraw all liquidity from a strategy and close it.

import { AquaProtocolContract, Address, HexString, AQUA_CONTRACT_ADDRESSES, NetworkEnum } from '@1inch/aqua-sdk'
import { http, createWalletClient, isHex } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { mainnet } from 'viem/chains'
import assert from 'node:assert'
import 'dotenv/config'

const makerPrivateKey = process.env.MAKER_PRIVATE_KEY

assert(isHex(makerPrivateKey))
const app = '0xTODO_REPLACE'
const WETH = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'
const USDC = '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48'

const strategy = '0x' // parsed from ship events or fetched from api

// Initialize Aqua contract
const aqua = new AquaProtocolContract(AQUA_CONTRACT_ADDRESSES[NetworkEnum.ETHEREUM])

// Create ship transaction
const shipTx = aqua.dock({
  app: new Address(app),
  strategyHash: AquaProtocolContract.calculateStrategyHash(new HexString(strategy)),
  tokens: [new Address(USDC), new Address(WETH)]
})

// Send transaction
const wallet = createWalletClient({
  chain: mainnet,
  transport: http(),
  account: privateKeyToAccount(makerPrivateKey)
})

await wallet.sendTransaction(shipTx)

// After transaction is confirmed, all virtual balances are withdrawn
// and the strategy is closed
Full test example: tests/aqua.spec.ts - should dock

License
This SDK is provided under the terms described in LICENSE and THIRD_PARTY_NOTICES.

For any licensing questions or requests, contact:

license@degensoft.com
legal@degensoft.com